\documentclass[main.tex,fontsize=8pt,paper=a4,paper=portrait,DIV=calc,]{scrartcl}
\input{../ost-summary-template.tex}

\lstset{
    language={[x86masm]Assembler},
    style=code,
}

\begin{document}
\begin{table}[h!]
\section{\textbf{Processor interaction}}
\begin{tabular}{|m{0.2\linewidth}|m{0.755\linewidth}|}
\hline
\mc{Memory-bus} & \mc{This enumerates the memory, as it can't be attached to the cpu directly, it would simply be a too long string.} \\
\hline
\mc{Data-bus} & \mc{This bus handles the data of a memory address that either has been read, or we want to write to.} \\
\hline
\mc{Control-Signals} & \mc{These indicate if we want to write or read.}\\
\hline
\mc{} & \mc{\textcolor{Red}{Note that the processor only really interacts with the rest of the system with the databus, the rest is only used in order to make the interaction happen at all!}}\\
\hline
\mc{\textbf{Instruction Set}} & \mc{A processor has a certain instruction set, that accesses it's own immediate register as well as request data from cache/memory. This is also the problem with Intel and AMD, they can't opensource their hardware properly as the instruction set is licensed by intel to other vendors. Therefore all hail Risc-V!} \\
\hline
\mc{} & \mc{Instructions are something like copy value of x into y, or write value u into p. But, there is also the instruction to simply do nothing!} \\
\hline
\mc{Sequence} & \mc{Just as the name says, it's a sequence of instructions to do something more specific than writing a value. Programs for example are just sequences of instructions. As we know, this is stored inside memory and is as stated above accessed by memory-bus.} \\
\hline
\mc{cache} & \mc{extremely fast but small memory insdide the processor.} \\
\hline
\mc{register} & \mc{Special datastructure inside the cpu that is even faster and smaller than the cache.} \\
\hline
\mc{Machine-Code} & \mc{The machine code is simply the encoding which the Sequences have to be in, in order for the CPU to understand the instructions. This is also why ARM programs do not run on an x86 system. The memory instructions would not be readable by the cpu. Rosetta is essentially just decoding and encoding these instructions.} \\
\hline
\mc{System-clock-cycle} & \mc{The entire system runs by the processor clock-cycle, it has 2 states, one constant sate, where values can only be read, and one change-able state, where any other operation can be done.} \\
\hline
\mc{Processor-cycle} & \mc{ 1. Processor orders the instructions from the memory with pointer.\\
  2. Processor decodes the Operation and Operands from the instruction.\\
  3. Processor chooses the corresponding core part (Baustein \#FuckGerman).\\
  4. Active Core might read from register.\\
  5. Active Core (part of it) executes operation.\\
  6. Active Core might write to register.\\
  7. Processor moves pointer according to operation size.\\
} \\
\hline
\mc{Encoding of Operations} & \mc{\pictext{2022-09-23-03:58:36.png}{The left side is a chain consisting of the Operation code and the register code. For example: the operation code \(1B_h\) will be combined with the register \(02_h\). This will combine like this in binary: \(011011_b\) append \(01\) -> \(01101101\) which is \(6D_h\) }[0.2,0.3,0.55]} \\
\hline
Little Endian Intel & Intel uses Little Endian due to certain benefits with this mode. \newline
\textbf{\emph{The biggest benefit is the fact that byte, word, dword all have the same address!}}\newline
\textbf{\emph{Remember from digicode, little endian is. \( s_1s_0\) \(s_3s_2\)}}\newline
\pic{2022-09-27-03:35:55.png}\\
\hline
Bit Byte and Word & Byte 8 Bit \newline 
Word 2 Byte / 16 Bit \newline
Doubleword 4 Byte / 32 Bit, or DWord \newline
Quadword 8 Byte / 64 Bit,or QWord \newline
Double Quadword 16 Byte / 128 Bit, or DQWord\\
\hline
Smallest Bit Count\newline
in the intel architecture & \textbf{The smallest amount that you can use in the intel architecture is 8bit}, in other words 1 byte. \newline You can't manipulate 1 single bit without taking 7 more with you.\\
\hline
\textbf{Register Formats} & \minipg{ 
In 16 bit architecture we have AH and AL registers, both being 8 bit.\newline
These accumulate to the \textbf{AX} Register.\newline
With 32 bit we get to \textbf{EAX} which extends the 16 bit by another 16 to the left.\newline
64 bit extends this further with another 32 and the name \textbf{RAX}.\newline
}{\pic{2022-10-04-03:34:45.png}}[0.5,0.5]\\
\hline
\end{tabular}
\end{table}
\pagebreak
\begin{table}[h!]
\begin{tabular}{|m{0,2\linewidth}|m{0.755\linewidth}|}
\hline
\emph{Further Terminology} & 
\minipg{
\begin{itemize}
  \item  \textbf{RAX} Accumulator for some operations, when none other is available
  \item  \textbf{RCX} Counter for loops or stringoperations
  \item  \textbf{RDX} Pointer for I/O Operations 
  \item  \textbf{RBX} Datapointer
  \item  \textbf{RSI,RDI} Source and Target-indices for stringoperations -> write your string to this
  \item  \textbf{RSP} Stackpointer, address for allocated stack
  \item  \textbf{RBP} Basepointer, address outside of stack, base for operation
  \item  \textbf{R8-R15} additional registers
\end{itemize}}
{\pic{2022-10-04-03:42:25.png}}[0.5,0.5]\\
\hline
\textbf{Length of Instruction} & 
\vspace{2mm}
\begin{itemize}
  \item Instructions are binary numbers which encode Operations and Operands
  \item Instructions can be 1-15 bytes long on the x86-64 architecture
  \item Count and size of parameters are dependend on the operation
  \item The length of an instruction is \textbf{not} included in the sequence
  \item A sequence must iterate through instructions to encode each instruction.\newline
  From start to finish.
  \vspace{-3mm}
\end{itemize}\\
\hline
\end{tabular}
\subsection{Operations}
\begin{tabular}{|m{0.2\linewidth}|m{0.755\linewidth}|}
\hline
\emph{Operations} & 
\vspace{2mm}
\begin{itemize}
  \item \textbf{Datatransfer Operations}
  \item \textbf{Arithmetic Operations}
  \item \textbf{Programflow Operations}
  \item \textbf{String Operations}
  \item \textbf{Operation for communication with the device}
  \item \textbf{Other Operations: Random Number Generator, Capability request}
  \vspace{-3mm}
\end{itemize}\\
\hline
\textbf{Runtime of Operations} & 
\vspace{2mm}
\begin{itemize}
  \item slowest Operations like Division take longer like 100 cycles. Some less than 1!
  \item Operations that need to access the memory need to wait for it,\newline
  this means that the runtime is variable: \newline
  \textbf{Operand in cache 4-70 cycles}\newline
  \textbf{Operand not in cache multiple hundreds of cycles!!}\newline
  \textcolor{red}{In other words a pc without a cache is useless!}
\item Not all operations can be optimized, others only with extensive measures like division.
  \vspace{-3mm}
\end{itemize}\\
\hline
\hline
\end{tabular}
\end{table}
\pagebreak
\begin{table}[h!]
\section{Assembly}
\begin{tabular}{|m{0,2\linewidth}|m{0.755\linewidth}|}
\hline
assembler \newline 
assembly & This is the "compiler" of assembly. Be aware this is \textbf{platform specific!!} we will use \emph{Netwide Assembler NASM}\newline This is a programming language.\\
\hline
Assembler converts instructions\newline directly into binary. & db 48 | Byte 48d \newline
db 0x35, 0h21, 049h | Bytes 35h , 21h , 49h \newline
db ’a’ | with ASCII-Code of a = 61h \(\equiv\) db 0x61 \newline
db ’Hello’ | ASCII-Codes of H, e, l, l and o \(\equiv\) db 0x48, 0x61, 0x6c, 0x6c, 0x6f\newline
Word       | dw 0x2135 | \(\equiv\) db 0x35, 0x21\newline
Doubleword | dd 0x2135 | \(\equiv\) db 0x35, 0x21, 0x00, 0x00, \newline 
Quadword   | dq 0x2135 | \(\equiv\) db 0x35, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 \\
\hline
Numbers in assembly & 200 | 0200d | 0d200 | 0c8h | \$0c8h | 0xc8 | 0hc8 \newline
11001000b | 1100\_1000b | 1100\_1000y | 0b1100\_1000 | 0y1100\_1000
\\
\hline
Pointers in Assembly & \vspace{2mm}\includegraphics[scale=0.2]{2022-09-27-04:12:53.png} \newline
1AF8 now has a pointer in another place. \newline
\includegraphics[scale=0.2]{2022-09-27-04:17:16.png}\newline
This would also produce the same result. Aka you can use labels before the operation.\newline
\includegraphics[scale=0.2]{2022-09-27-04:24:38.png}\\
\hline
A simple length calculation in assembly & \vspace{2mm} \includegraphics[scale=0.2]{2022-09-27-04:27:52.png}\newline 
First we define a label called length, but we can't calculate this yet as my\_text and after\_my\_text aren't defined yet.\newline
So we continue to the next line, here we write BSys 1?! and set the value of my\_text to 08 00 00 00 00 00 00.\newline
Then we define after\_my\_text with the value of the offset at this point, which is 0F 00 00 00 00 00 00 00.\newline
At last the length will have the value of 08 00 00 00 00 00 00 00, which is the length of BSys 1?!.\\
\hline
\textbf{\emph{Flat-Form Binaries vs Object-files}} & \textcolor{red}{The first is a simple binary of pure binary. Aka Machine-Code.}\newline
\textcolor{blue}{The second is the linked version with a symboltable to define labels.}\\
\hline
\textbf{\emph{Generate Object-file}} & \textbf{nasm -f elf64 prog.asm -o prog.o}\\
\hline
\textbf{\emph{Analyze Object-file}} & \textbf{objdump -t -d - Mintel prog.o}\newline
-t show symboltable \newline
-d disassemble\newline
-Mintel dissasemble code in intel format, aka show NASM format instead of GCC.\\
\hline
Assembly dumps in action & \vspace{2mm} \includegraphics[scale=0.2]{2022-09-27-04:45:55.png} \includegraphics[scale=0.2]{2022-09-27-04:46:02.png}\newline
write 2 bytes aka a word to file. offset is now at 16, or 10 in hex.\newline
Now we use label w, which is at offset 10h, then we write 0x12345678 size 8h.\newline
label x, offset 18h, write 0xCAFEFACE size 8h.\newline
label y, offset 20h, write z, \textbf{\emph{but this is empty until compiled!}}
\\
\hline
\textbf{mov Target/Sink, Source} & 
\vspace{2mm}
\begin{itemize}
  \item copy from source into target
  \item after execution of operations, the source and target/sink have the same value
  \item \emph{\textbf{Target <- Source}}
\end{itemize}
Here an example: \newline
mov rax, eax \t --> move register to register (no memory access) \newline
mov rax, 0x4000 \t --> move constant into register (no memory access)\newline
mov rax, [eax] \t --> move memory address of value eax into rax (memory access!)\\
\hline
\textbf{mov rules} &
\vspace{2mm}
\begin{itemize}
  \item \emph{move eax, ebx} | move 32 bit into 32 bit // ok
  \item \emph{move eax, rbx} | move 64 bit into 32 bit // ERROR!
  \item mov [0x8000], rax | put content of memory \(8000_h\) ... \(8007_h\) to the content of rax
  \item mov [0x8000], 5 | put content of memory \(8000_h\) ... \(8007_h\) to 5
  \item \textbf{HOWEVER, you can't move from memory to memory!}
  \item \textcolor{red}{mov [0x8000], [0x9000] ERROR!!!!!}
  \vspace{-3mm}
\end{itemize}\\
\hline
\end{tabular}
\end{table}
\pagebreak
\begin{table}[h!]
\begin{tabular}{|m{0,2\linewidth}|m{0.755\linewidth}|}
\hline
Operand size with memory & 
\vspace{2mm}
\begin{itemize}
  \item 8 bit: mov al, [0x8000] | copy content of 1 byte to al
  \item 16 bit: mov ax, [0x8000] | copy content of 2 bytes to ax
  \item 32 bit: mov eax, [0x8000] | copy content of 4 bytes to eax
  \item 64 bit: mov rax, [0x8000] | copy content of 8 bytes to rax \newline
  \textcolor{red}{assembly copys as much as it can into the operand.}
  \vspace{-3mm}
\end{itemize}\\
\hline 
\textbf{\textcolor{teal}{Displacement and Base}}&\minipg{
\pic{2022-10-04-04:29:18.png}\newline
\textcolor{red}{\textbf{Displacement is the use of an address directly -> [0x8000]}}}
{\pic{2022-10-04-04:29:27.png}\newline
\textcolor{green}{\textbf{Base is the use of an address with a variable -> [rbx]}}}[0.4,0.4]\\
\hline
\textbf{\textcolor{teal}{Scaled Index}} &
[i * s]
\begin{itemize}
  \item Index i is a register
  \item Scale s is the constant 1,2,4 or 8 -> bytes!
  \item The address is i * s
  \item The index is therefore scaled
\end{itemize}
mov rcx, 0x1000 \newline
mov rax, [rcx * 8] // rcx multiplied by 8. Since rcs is 0x1000 -> 0x8000\newline
Or you can also write it like this:\newline
mov rbx , 0 x4000\newline
mov rcx , 0 x1000\newline
mov rax , [0 x2000 + rbx + rcx * 2]\newline
\\
\hline
\textbf{Hello World in assembly} &
\begin{lstlisting}
hello: db 'Henlo Birb' ;db something -> write your text
hello_length: equ $ - hello ;hello_length is equal to the current pointer minus hello

global _start         ; specifies the scope of a variable
_start:               ; like main in cpp
mov rax, 0x1          ; move system write instruction into register -> write instruction is 1
mov rdi, 0x1          ; specifies to write to the IO register 
mov rsi, hello        ; move text into write register
mov rdx, hello_length ; move write pointer to before rsi
syscall               ; call the os to do something

mov rax, 60           ; move system exit instruction into register -> 60
mov rdi, 0            ; ? exit code for string operation?
syscall               ; call the os to do something
\end{lstlisting}\\
\hline
\textbf{Instructions} & 
\vspace{2mm}\large
\begin{itemize}
\item mov rax, 1 \textcolor{teal}{//move the value 1 into rax, keep in mind that mov can hold other operations!}
\item equ rax, 1+1 \textcolor{teal}{//arithmic operation}
\item add z,   q  \textcolor{teal}{// z + q} 
\item sub z,   q  \textcolor{teal}{// z - q}
\item adc z,   q  \textcolor{teal}{// z + q + c (carry bit from previous calculation)}
\item sbb z,   q  \textcolor{teal}{// z - q - c (carry bit from previous calculation)}
\item neg z       \textcolor{teal}{// 0 - z ("zweierkomplement")}
\item inc z       \textcolor{teal}{// z++ }
\item dec z       \textcolor{teal}{// z-- }
\item mul z,      \textcolor{teal}{// multiply with implicit 2.operand }\newline
mul rbx -> RDX:RAX <-- RAX * RBX
\item imul z,   i  \textcolor{teal}{// signed equivalent for mul, z * i }
\item div z,      \textcolor{teal}{// divide with implicit 2.operand}\newline
div rbx  \newline
d = RDX:RAX\newline
RAX <-- RDX:RAX / RBX\newline
RDX <-- RDX:RAX mod RBX
\item shl z,   i  \textcolor{teal}{// z * \(2^i\)               --> shift}
\item shr z,   i  \textcolor{teal}{// z * \(2^{-i}\) z signed   --> shift}
\item sar z,   i  \textcolor{teal}{// z * \(2^{-i}\) z unsigned --> shift}
\item rol z,   i  \textcolor{teal}{// Left-Rotate i Bits }
\item ror z,   i  \textcolor{teal}{// Right-Rotate i Bits }
\end{itemize}
\, \newline
\textcolor{teal}{cmp: This instruction essentially does the same as sub rax, rbs, however,\newline
the difference is that sub will overwrite the rax value, cmp will not!\newline
\textbf{cmp will only set the flags!}}\newline
\\
\hline
NAND in Assembly & 
\begin{lstlisting}
mov rax,  [x] ; rax <- x
mov rbx,  [y] ; rbx <- y
and rax,  rbx ; rax <- x AND y
not rax       ; rax <- NOT ( x AND y )
mov [z], rax  ; z   <- NOT ( x AND y )
\end{lstlisting}\\
\hline
Size in Assembly & 
\textcolor{orange}{With certain instructions, the size can't be derived\newline
here we need to specify the size!}\newline
\begin{lstlisting}
not word [myvar] ; the word being the size
\end{lstlisting}\\
\hline
\end{tabular}
\end{table}
\pagebreak
\begin{table}[h!]
\section{Linker}
\begin{tabular}{|m{0,2\linewidth}|m{0.755\linewidth}|}
\hline
Movation & 
\vspace{2mm}
\begin{itemize}
  \item translate files
  \item \textbf{translate iteratively, only translate those that have changed!}
  \item \textbf{distribute development to many people!}
  \item \textbf{version control}
\vspace{-3mm}
\end{itemize}\\
\hline
Unlinked files in C C++ and assembly & \textcolor{red}{The UND is means that there is a not yet linked symbol!}\newline 
\pic{2022-10-04-04:41:27.png}\\
\hline
Partial Linking & 
\textbf{ld -r prog.o prog2.o -o prog3.o}  | This links our missing symbol from above!\newline
\pic{2022-10-04-04:44:56.png}\\
\hline
\textbf{Creation an executable} & 
\pic{2022-10-04-04:49:23.png}\newline
\begin{itemize}
  \item ld //the tool
  \item -e // flag for executable
  \item main // the entry point!
  \item my\_prog.o // the object file to use
  \item -o // outputflag
  \item my\_prog // the name of the executable to create
\vspace{-3mm}
\end{itemize}\\
\hline
\textbf{Syscall / End of a Program} & \minipg{ 
\begin{itemize}
  \item mov rax, 60 | \textbf{OS-Syscall exit code -> 60} |put 60 into rax
  \item rdi, 0 | \textbf{8 bit exit code} | exit code 0 aka successful
  \item syscall | \textcolor{red}{execute rax code -> exit!}
\vspace{-3mm}
\end{itemize}}
{\pic{2022-10-04-04:52:29.png}}[0.39,0.4]\\
\hline
\end{tabular}
\end{table}
\pagebreak
\begin{table}[ht!]
\section{C Toolchain}
\begin{tabular}{|m{0.977\linewidth}|}
\hline 
\minipg{
\textcolor{red}{The C Toolchain consists of:}\newline
\begin{itemize}
  \item \textcolor{teal}{C Preprocessor} 
  \item \textcolor{teal}{C Compiler} 
  \item \textcolor{teal}{Assembler} 
  \item \textcolor{teal}{Linker} 
\end{itemize}
}{
  C just like C++ has 3 parts:\newline
  \begin{itemize}
    \item \textcolor{teal}{Preprocessor} -> parts like \#include
    \item \textcolor{teal}{Base contructs} -> variables function etc inside one file and in the base language
    \item \textcolor{teal}{Standard libraries} -> additional function and types 
    \vspace{-3mm}
  \end{itemize}
}\\
\hline
\end{tabular}
\section{C Preprocessor}
\begin{tabular}{|m{0.2\linewidth}|m{0.755\linewidth}|}
\hline
1. Iteration & 
In the first iteration the preprocessor removes all comments from the code.\\
\hline
2. Iteration &
The preprocessor tokenizes the code, so the compiler has an easier time later on.\newline
\textcolor{teal}{Here are the possible tokens:}
\begin{itemize}
  \item \textcolor{teal}{Identifier}\newline
    starts with a-z or A-Z followed by letters, digits, or \_
  \item \textcolor{teal}{Preprocessor Number}\newline
    starts with a digit followed by digits, numbers, \_, ., or exponents
  \item \textcolor{teal}{String or Character literals}\newline
    String starts with ""\newline
    Character starts with ''\newline
    Escape character is \textbackslash
  \item \textcolor{teal}{Operations and punctuators}\newline
    \pic{2022-10-11-03:40:12.png}\newline
    \textcolor{orange}{The C preprocessor is greedy, it means that it will always take the biggest possible token}
  \item \textcolor{teal}{others}

\end{itemize}
\, \newline
\textcolor{orange}{The whitespaces, tabs and newlines seperate the tokens, however not all tokens need to be seperated, such as a+b.}\newline
\pic{2022-10-11-03:35:25.png}\\
\hline
3. Iteration & 
Here the C preprocessor simply \textbf{executes preprocessor directives} and \textbf{replaces macros} with code.\\
\hline
Function & Preprocessor handles such things as \#include \#define and more.\newline
They are simply used to put the code into one piece again, something that we humans are too dumb to do :P\\
\hline
\end{tabular}
\subsection{Preprocessor Commands:}
\begin{tabular}{|m{0.2\linewidth}|m{0.755\linewidth}|}
\hline
\#ifdef / \#ifndef \newline \#define \newline \#endif & These are used to check if things are already defined, or to define them. Either for checks to avoid double definition, or to check if debug is used -> ifdef DEBUG\\
\hline
Include differences & \#include <library> \textcolor{teal}{search in the system include directories!}\newline
\#include "library" \textcolor{teal}{search in the current working directory, \textbf{AND after that in the system includes}}\\
\hline
\#pragma once & This is used to automatically avoid double include statements. Aka if it is included already simply ignore any double includes. \\
\hline
\textbf{Cmake} & cmake -B build | this will define the directory to build in \newline cmake --build directory | this will build the system into this directory \newline cmake . | creates the CMakeFile and other files inside the specified director
\\
\hline
\textbf{Macros (simple object version)} & 
\#define XYZ 123 \newline
int x = XYZ compiles to int x = 123\newline 
\textcolor{orange}{Macros can't be a single character !}\\
\hline
\textbf{General Rule} & \emph{Only include what's necessary, don't just generalize includes to include everything!}\\
\hline
\end{tabular}
\section{C Compiler / Linker}
\begin{tabular}{|m{0.2\linewidth}|m{0.755\linewidth}|}
\hline
Commands &
\begin{itemize}
  \item gcc prog.c -o prog \textcolor{teal}{compile and link the prog.c with the ouput prog}
  \item gcc -c prog.c \textcolor{teal}{only compile the program -> prog.s as output}
  \item gcc -masm=intel -S prog.c \textcolor{teal}{only compile without assembling -> prog.o as output}
  \item gcc -E prog.c > prog.prep.c \textcolor{teal}{only run preprocessor commands -> prog.prep.c as output}
  \vspace{-3mm}
\end{itemize}\\
\hline
Function & 
\textcolor{orange}{\textbf{The compiler translates a pure c file (no preprocessor commands) to an assembly file}}\\
\hline
\end{tabular}
\end{table}
\begin{table}[ht!]
\begin{tabular}{|m{0.2\linewidth}|m{0.755\linewidth}|}
\hline
Translation example from C to Assembly &\pic{2022-10-11-04:26:03.png}\\
\hline
\textbf{\emph{Declaration}}
&
This only declares the variable, it does not have a predefined value -> undefined behavior!\newline
\begin{lstlisting}
exter int i;
extern char c;
\end{lstlisting}
\,\newline
\textcolor{red}{\textbf{PLEASE, note the \emph{extern} keyword}}\newline
\textcolor{orange}{This means that only a tag is declared, there is no memory allocation yet.\newline
Without extern the memory is allocated, this is as the extern expects the variable to be declared/defined somewhere else}\\
\hline
\textbf{\emph{Definition}}
&
This defines a variable with a set value.\newline
\begin{lstlisting}
int i = 5;
int a{5};
\end{lstlisting}
\\
\hline
\end{tabular}
\begin{tabular}{|m{0.2\linewidth}|m{0.3665\linewidth}|m{0.3665\linewidth}|}
\hline
Assembly vs C Declaration and Definition &
Assembly:\newline 
\begin{lstlisting}
my_var : dq 0 x4000
mov rax , [ my_var ]
\end{lstlisting}
\, \newline
C:\newline
\begin{lstlisting}
int my_var;
\end{lstlisting}
&
Assembly:\newline
\begin{lstlisting}
x : dd 15
\end{lstlisting}
\, \newline
C:\newline
\begin{lstlisting}
int x = 15;
\end{lstlisting}
\\
\hline
\end{tabular}
\begin{tabular}{|m{0.2\linewidth}|m{0.755\linewidth}|}
\hline
\textbf{static keyword} & 
\textcolor{red}{as there are no classes in C, the static keyword is used for something else\newline
This means that the variable can't be exported!!}\newline
\begin{lstlisting}
static int c = 5;
\end{lstlisting}
\, \newline
\pic{2022-10-11-11:12:14.png}\\
\hline
\textbf{Identifiers} & 
Identifiers are needed to format the output of \textcolor{teal}{printf} as a certain number/type.\newline
\begin{itemize}
\item \textcolor{teal}{sizeof(Integer) as signed decimal = \%d}
\item \textcolor{teal}{sizeof(Integer) as unsigned decimal = \%u}
\item \textcolor{teal}{sizeof(Integer) as hexadecimal = \%x or \%U}
\item \textcolor{teal}{sizeof(long) as signed decimal = \%li}
\item \textcolor{teal}{sizeof(long long) as signed decimal = \%lli}
\item \textcolor{teal}{sizeof(void *) as pointer (hexadecimal -> address) = \%p}
\item \textcolor{teal}{sizeof(cahr *) as pointer (null terminated string) = \%s}
\item \textcolor{teal}{sizeof(double) as floating point decimal = \%f}
\item \textcolor{teal}{}
\item \textcolor{teal}{}
\vspace{-3mm}
\end{itemize}\\
\hline
\end{tabular}
\subsection{Objects in C}
\begin{tabular}{|m{0.977\linewidth}|}
\hline
\textcolor{orange}{\textbf{C is not object oriented, objects are not the same as in C++}\newline
When we talk about objects in C, then we talk about any variable instance, for example an integer is an object.}\newline
\textcolor{teal}{Each object has some sort of value, for integer this is a number.}\newline
\textcolor{blue}{\textbf{In the end, an object is just an allocation of memory!}}\newline
The reason for this is that we once thought we might have a different way of storing things at some point\newline
Turns out this was wrong and we still use memory for storing everything.\\
\hline
\end{tabular}
\begin{tabular}{|m{0.2\linewidth}|m{0.755\linewidth}|}
\hline
Operations in C & 
\textcolor{orange}{C will enforce operand type equality, this means that it will try to cast to get this,\newline
or it will simply not work.}\\
\hline
Existence of types & 
Just like c++, after you compile C, it will no longer have types, just like assembly.\newline
Types only exist to make it easier to program.\\
\hline
\textbf{sizeof(T)}&
\textcolor{orange}{Each type has a size that you can check, however, this is compiler, OS and even architecture dependent!\newline This can therefore not be taken for granted.}\newline
\textcolor{red}{However, this is one of the reasons that C and C++ is so fast!}\\
\hline
\textbf{\textcolor{red}{minimum} size of variables}&
\vspace{2mm}
\begin{itemize}
  \item \textcolor{teal}{signed char} \(\geq\) 8 Bit
  \item \textcolor{teal}{short int} \(\geq\) 16 Bit
  \item \textcolor{teal}{int} \(\geq\) 16 Bit \(\geq\) short
  \item \textcolor{teal}{long int} \(\geq\) 32 Bit
  \item \textcolor{teal}{long long int} \(\geq\) 64 Bit
  \item \textcolor{teal}{void} no real value!
  \vspace{-3mm}
\end{itemize}\\
\hline
\end{tabular}
\end{table}
\pagebreak 
\begin{table}[ht!]
\begin{tabular}{|m{0.2\linewidth}|m{0.755\linewidth}|}
\hline
signed or unsigned & 
\textcolor{orange}{Just like in c++ you can write unsigned to get the max possible positive number.\newline
the default is signed, which has both negative and positive values!}\\
\hline
Other Types in C & 
\vspace{2mm}
\begin{itemize}
  \item \textcolor{teal}{Array-Types}
  \item \textcolor{teal}{Struct-Types}
  \item \textcolor{teal}{Union-Types}
  \item \textcolor{teal}{Pointer-Types}
  \item \textcolor{teal}{Function-Types}
  \vspace{-3mm}
\end{itemize}\\
\hline
Pointer types& 
\textcolor{orange}{\textbf{A pointer is just a number, it is an integer}}\newline
\textcolor{teal}{They simply \emph{point} to an address, this an be any address even another pointer address!}
\begin{lstlisting}
int num = 5;
int* nump; // pointer to int
int num2 = *nump; 
// dereference the pointer and assign the value of it to num2
int** numpp = &nump;
// create a pointer to a pointer with the address of nump
\end{lstlisting}
\\
\hline
Decimal,Octal and Hex & 
\vspace{2mm}
\begin{itemize}
  \item \textcolor{teal}{Decimal: 0..9 with \textbf{NO 0 at the start}} 
  \item \textcolor{teal}{Octal: 0..7 with a \textbf{leading 0}} 
  \item \textcolor{teal}{Hex: 0..F with \textbf{0x at the start}} 
  \item \textcolor{teal}{Suffix: the suffix specifies the type:}\newline
    l long,ll long long ,u unsigned,ul .. ,ull ..
  \vspace{-3mm}
\end{itemize}\\
\hline
Casts & 
\textcolor{orange}{Casts are just like in c++}\newline
\begin{lstlisting}
double ping = 5.5;
int pang = (int)ping;
\end{lstlisting}\\
\hline
Bitwise Operators & 
\vspace{2mm}
\begin{itemize}
  \item \textcolor{teal}{not: \(\tilde{} \) q}
  \item \textcolor{teal}{and: q \& p }
  \item \textcolor{teal}{or: q | p}
  \item \textcolor{teal}{or: q \^ p}
  \item \textcolor{teal}{or: q << p} left shift
  \item \textcolor{teal}{or: q >> p} right shift
\end{itemize}
\, \newline
\textcolor{teal}{Bitwise operators always return the same type we entered!}\newline 
\textcolor{orange}{Unlike assembly, you can't use rotate directly!} \\
\hline
Arithmic Operators& 
\vspace{2mm}
\begin{itemize}
  \item \textcolor{teal}{not: !q}
  \item \textcolor{teal}{and: q \&\& p}
  \item \textcolor{teal}{or: q || p}
  \item \textcolor{teal}{greater than: >}
  \item \textcolor{teal}{smaller than: <}
  \item \textcolor{teal}{greater than or equal: >=}
  \item \textcolor{teal}{smaller than or equal: <=}
\end{itemize}
\, \newline
\textcolor{red}{\textbf{The return type of these is int NOT bool!}}\newline
The reason for this is that C is a very old language and bool didn't exist when it was created.\\
\hline
Function parameters in C &
\textcolor{orange}{C handles function parameters in a weird way, you can call a function with no parameters with any amount of parameters. If you want to explicitly state that you do not want any parameters, then you need to include the parameter "void" in the declaration. C++ doesn't do this!}\newline
\begin{lstlisting}
void f();
void b(void);
// formatting to keep the lines shorter
void f() { printf("pangping!"); } // ok
void f(1,2,3,4) { printf("pangping!"); } // ok LMAO
void b() { printf("pangping!"); } // ok
void b(1,2,3,4) { printf("pangping!"); } // !!ERROR!!
\end{lstlisting}\\
\hline
Copy by default & 
\textcolor{orange}{Just like c++ all parameters will be copied by default, if you want to use the same object, use pointers! \textbf{yes RAW POINTERS not references! That is another c++ feature!}}\newline
\begin{lstlisting}
int x = 5;
void f(int x) {
  x = x + 1;
} // x is still 5 as the parameter was copied!
void b(int *x) {
  *x = *x + 1;
} // now x is 6 as we used the pointer!
\end{lstlisting}\\
\hline
Global vs Local variables & 
\textcolor{orange}{Global variables will always be \textbf{initialized as 0 if we do not initialize it ourselves!}}\newline
\textcolor{purple}{Local variables on the other hand \textbf{will not be initialized by the compiler, aka it will be the value that the memory address it has at that point!}}\newline
\textcolor{teal}{The simple reason for this, is that the global variables are allocated on the heap, they have a fixed memory address, where as the local variables are on the stack!}\\
\hline
Function Pointers & 
\textcolor{orange}{Functions can be called by using pointers, quite nice:}\newline
\begin{lstlisting}
int g ( int x , int y );

int (*p) (int, int) = &f ;
p = g;
i = (*p) (1, 2); // calls the function g with parameters (1, 2)
j = p(3, 4); // same
\end{lstlisting}\\
\hline
\end{tabular}
\end{table}
\pagebreak 
\begin{table}[ht!]
\section{Pointers in C}
\begin{tabular}{|m{0.2\linewidth}|m{0.755\linewidth}|}
\hline
Raw Pointers & 
Just like c++:\newline
\begin{lstlisting}
int32_t j = 10;
int32_t *y = &j;
// y now points to j

y++;
// y skips 4 bytes as int32_t has size of 4 bytes!
// also note that this is pointer is now pointing to trash data!!
\end{lstlisting}\\
\hline
Index-Operators with Pointers & 
For whatever reason this is possible, note that \textbf{one operand needs bo be a pointer and one needs to be an integer! But it doesn't matter which one!}\newline
\begin{lstlisting}
a[b] == *(a+b)
int32_t x = 0;
int32_t * y = & x ;
y[0] = 0x42 ;     // same as : x = 0 x42
(&x)[0] = 0x42 ; // same
0[&x] = 0x42 ;   // same
100[200] = 0x42 ;  // Error : no address
\end{lstlisting}\\
\hline
Pointer to Arrays & 
\vspace{2mm}
\begin{lstlisting}
int32_t a[10]; // array with 10 integers
int* b[10]; // 10 pointers to ints
void* c[10]; // 10 voidpointers
int* d[3] = {1,2,3}; // array with elements initialized
int* d[] = {1,2,3}; // same but size inferred

// usage
int h = d[2]; // h equal to 3
\end{lstlisting}\\
\hline
sizeof() & 
The sizeof function will \textbf{return the size of the type with regular types like integers and chars}, and it will \textbf{return the length of an array!}\newline
\begin{lstlisting}
int g = 8;
int* b[] = {3,4,5,6,7};
printf(%d,g); // prints 8
printf(%d,b); // prints 5 -> the amount of elements
\end{lstlisting}\\
\hline
size\_t & 
size\_t is the return value of sizeof which is big enough to hold any object.\newline
It provides a datatype to iterate over arrays.\newline
\textbf{it's essentially an iterator}\newline
\begin{lstlisting}
for (size_t i = 0; i < something; i++) {
  a[i] = 0;
}
\end{lstlisting}\\
\hline
typdef & 
Typedef are type aliases that can be used when you have a ridiculous long typename.\newline
\begin{lstlisting}
typedef int int_t; // int is int_t type
\end{lstlisting}\\
\hline
Function-Alias &
\vspace{2mm}
\begin{lstlisting}
// Function pointer type with name function_t
// for functions returning an int
// and having one parameter of type pint_t
typedef int (* function_t ) ( pint_t );
int calculate (pint_t);
function_t callback = calculate; // No call
function_t callback2 = &calculate; // same , & is optional
int x = 0;
int y = (*callback) (&x);// calls calculate
\end{lstlisting}\\
\hline
Predefined Aliases & 
There are a bunch of aliases that are predefined:\newline
\begin{itemize}
\item \textcolor{purple}{int8\_t, int16\_t, int32\_t, int64\_t}
\item \textcolor{purple}{intmax\_t: biggest signed integer}
\item \textcolor{purple}{untptr\_t: signed integer which its into an address}
\item \textcolor{purple}{uint8\_t, ..., uintmax\_t: ungsigned variants of above}
\item \textcolor{purple}{size\_t: result type of sizeof(t)}
\vspace{-3mm}
\end{itemize}\\ 
\hline
Subtraction on Pointers & 
You can only subtract pointers when they are of equal size\_t, this means the underlying type needs to be same!\newline
\begin{lstlisting}
int32_t *a = 100;
int32_t *b = 120;
uint32_t *c = 140;
ptrdiff_t y = a - b; // ok
prtdriff_t z = a - c; // ERROR signed and unsgined not the same!
\end{lstlisting}\\
\hline
Strings in C & 
In C we do not have a standard string, instead we need to use a char array:\newline
\begin{lstlisting}
// explicitly with array
char s [] = { 'H ' , 'a ' , 'i ' , '\0 ' };
// same as char s [] = { ' H ', 'a ', 'i ', 0};
char *pc = s ;

// implicitly with pointer
char *s = "Hai"; //best version
while (*pc != '\0') {
  // do something
  ++ pc ;
}
\end{lstlisting}\\
\hline
\end{tabular}
\end{table}
\pagebreak
\begin{table}[ht!]
\begin{tabular}{|m{0.2\linewidth}|m{0.755\linewidth}|}
\hline
Arrays as parameters & 
You can't be passed by value as a whole, instead you pass the pointer, \textbf{even when the parameter type is declared as a full array!}\newline
\begin{lstlisting}
int f ( int * a ) { /* ... */ }  // passes pointer
int f ( int a []) { /* ... */ }  // passes pointer
int f ( int a [4]) { /* ... */ } // passes pointer
\end{lstlisting}\\
\hline
Arrays will not know about their size & 
This means that you will need to pass an additional parameter in order for you to iterate over the array!\newline
\begin{lstlisting}
int some_func (int *a, int n) {
  for (int i = 0; i < n; ++i) {
    a [i] = 0;
  }
}
// small note, with char* [] you can ommit this parameter,
// as the last char will always be the terminating char \0 !
\end{lstlisting}
\, \newline
\textcolor{red}{There is a small problem with strings should you NOT pass the size parameter, it could potentially lead to reading of unowned memory -> overread exploit,\newline
in case the null termination won't happen!}\\
\hline
const & 
const simply means that \textbf{you can't change the value, but other functions etc might be able to change it!}\newline
This is in contrast to C++ and rust which both define something to be universally const if defined as const.\newline
\textcolor{OliveGreen}{Also, the const will always be for the type on the left of the const word, this means you can make a pointer to a const type,\newline
or you can make a const pointer:}\newline
\begin{lstlisting}
char const *c; // Pointer to const char
char *const d;     // const Pointer to char
++c;               // OK : c is pointer
5 ++d;             // Error : d is const pointer
6 *c = 'a';        // Error : * c is const char
7 *d = 'a';        // OK : * c is char
\end{lstlisting}\\
\hline
Predefined String operations &
\begin{itemize}
  \item \textcolor{purple}{size\_t strlen (char const *str, size\_t max)}\newline
  returns the length of the string
\item \textcolor{purple}{int strcmp (char const *a, char const *b)}\newline
  compares the string by comparing each char from left to right
\vspace{-3mm}
\end{itemize}\\ 
\hline
Structs & 
Structs are the same as in C++, without the additional benefits of methods etc, as C does not have classes and is not an OOP language.\newline
\begin{lstlisting}
// with names
struct something {
  char c;
  int b; 
  // more...
} t; // explained below
// without names, used for global variables... 
struct {
  int q; 
  // ...
}; // exlained below

struct something myStruct; // both names are necessary to instantiate a struct in C!!
\end{lstlisting}
\, \newline
\textcolor{OliveGreen}{The \textbf{t is an instance of the struct, in other words it defines a variable with that name already!}}\newline
\textcolor{red}{Also note that instantiating a struct requires the full name as follows: \textbf{struct structname variablename}!!}\\
\hline
Accessing members of structs & 
It is just like c++ with a dot in case of a full variable, or an arrow in case of a pointer: \newline
\begin{lstlisting}
struct something a;
struct something *b;
a.c = 'H';
a.b = 10;
b->c = 'E';
b->b = 50; 
// or with a list 
struct something c = {'A', 3};
\end{lstlisting}\\
\hline
Complete vs Incomplete types & 
A type is considered \textbf{complete if you know the size at compiletime}, otherwise the type is \textbf{considered incomplete when it has an unknown size at compile time.}\newline
\textbf{Incomplete types} need to be stored \textbf{on the heap!}\\
\hline
Forward Declaration & 
Sometimes you want need to declare something, then use it, but finish it later on to make it a complete type, in this case you can split the full declaration:\newline
\begin{lstlisting}
struct Folder ; // Forward - Deklaration
struct File {
  struct Folder * parent ; // OK : all pointer types have same size
  char name [256];         // OK : fixed size array
}; // --> Type complete
struct Folder {
  struct File * file [256]; // OK : fixed size array
}; // --> Type complete
\end{lstlisting}\\
\hline
Implicit integer conversion & 
Integers will always be implicitly converted to each other, this can lead to cases where the compiler will subtract \(2^n\) numbers until the conversion will work.\newline
\textbf{It is therefore recommended to only use explicit conversion rather than using implicit ones!}\\
\hline
\end{tabular}
\end{table}
\pagebreak
\begin{table}[ht!]
\begin{tabular}{|m{0.2\linewidth}|m{0.755\linewidth}|}
\hline
\textbf{Imul vs Mul} & 
\textcolor{orange}{(C) In case of 2 unsigned integers, we should technically use the mul instruction,\newline
however, the compiler will often use the imul instruction instead as it is better for optimization!\newline
The reason for the imul usage, is that 2 negative numbers would result in the same operation as 2 regular numbers\newline 
therefore 2 normal numbers will result in the same operation!}\newline
\textcolor{red}{Important with imul the signed integers will be treated as negative! But AGAIN this does \textbf{NOT} matter!!!}\\
\hline
\textbf{Carry Flag} & 
\textcolor{orange}{The carry flag signifies the \textbf{overflow with unsigned integers!}}\newline
\textcolor{teal}{0001 + 1111 = 0000 AND CF = 1 -> 1 + 15 = 0 -> CF = 1}\\ 
\hline
\textbf{Overflow Flag} & 
\textcolor{orange}{The  overflow flag signifies the \textbf{overflow with signed integers!}}\newline
\textcolor{teal}{0111 + 0001 = 1000 -> 7 + 1 = -8 (only 3 bits are for data!! first bit is the signature!!)}\\
\hline
CF vs OF &
\textcolor{red}{The compiler can't distinguish between unsigned or signed for a number, this is why it always sets both flags, later on the compiler needs to use the right one.\newline
This means on overflow, both values are set and then later on the right flag will be used based on the variable!}\\
\hline
\textbf{FlagList} & 
\vspace{2mm}
\begin{itemize}
\item \textcolor{teal}{CF:} Carry Flag, overflow for unsigned integers 
\item \textcolor{teal}{OF:} Overflow Flag, overflow for signed integers
\item \textcolor{teal}{ZF:} Zero Flag, will be set when the result is 0
\item \textcolor{teal}{SF:} Sign Flag, is the highest bit of the result -> leftmost byte (little endian)
\item \textcolor{teal}{PF:} Parity Flag, set if the lowest byte has an even number of bits
\vspace{-3mm}
\end{itemize}\\
\hline
\textbf{Condition Codes (CC)} & 
\textcolor{orange}{Certain instructions will only be used when a combination of flags is given -> Condition Code}\newline
\textcolor{teal}{Example: condition "Above" -> CF = 0 AND ZF = 0}\newline
\textcolor{green}{List of CC:}\newline
\begin{tabular}{|ll|ll|}
\hline
\textcolor{teal}{A : Above }& \textcolor{teal}{ -> CF = 0 AND ZF = 0}&
\textcolor{teal}{AE: Above or Equal } & \textcolor{teal}{ -> CF = 0}\\
\textcolor{teal}{B : Below } & \textcolor{teal}{ -> CF = 1}&
\textcolor{teal}{BE: Below or Equal } & \textcolor{teal}{ -> CF = 1 AND ZF = 1}\\
\textcolor{teal}{E : Equal }& \textcolor{teal}{ -> ZF = 1}&
\textcolor{teal}{G : Greater }& \textcolor{teal}{ -> SF = OF = 0 AND ZF = 0}\\
\textcolor{teal}{GE: Greater or Equal }& \textcolor{teal}{ -> SF = OF}&
\textcolor{teal}{L : Less }& \textcolor{teal}{ -> SF != OF}\\
\textcolor{teal}{LE: Less or Equal }& \textcolor{teal}{ -> SF != OF AND ZF = 1}&
\textcolor{teal}{PE: Parity Even} & \textcolor{teal}{ -> PF =1}\\
\textcolor{teal}{PO: Parity Old } & \textcolor{teal}{ -> PF = 0}&
\textcolor{teal}{Z:  Zero}&\textcolor{teal}{ -> ZF = 1} \\
\end{tabular}
\\
\hline
\end{tabular}
\end{table}
\pagebreak
\begin{table}[ht!]
\begin{tabular}{|m{0.2\linewidth}|m{0.755\linewidth}|}
\hline
Jumps & 
\textcolor{orange}{This is essentially goto!}\newline
\begin{lstlisting}
jmp 230 ; moves 230 down 
jmp -230 ; moves 230 up
; We can also jump to labels!!!!
  mov eax, [x]
  cmp eax, 3
  jne label1 ; jump to label1 if eax not equal to 3
  mov eax, [y]
  
label1: 
  inc eax
\end{lstlisting}\\
\hline
Conditional Mov & 
\textcolor{orange}{cmovCC: mov if condition is met! \textbf{the cc stands for the code!}}\newline
\begin{lstlisting}
mov rax, [ux]
mov rbx, [uy]
cmp rax, rbx
cmove rcx, 5 ; move 5 into rcx if rax and rbx are equal!
\end{lstlisting}\\
\hline
Conditional JMP & 
\textcolor{orange}{jCC: jmp if condition is met! \textbf{the cc stands for the code!}}\newline
\begin{lstlisting}
cmp rax, rbx
je 230 ; move 230 down if rax and rbx are equal
\end{lstlisting}\\
\hline
Conditional SET &
\textcolor{orange}{setCC: set if condition is met! \textbf{the cc stands for the code!}}\newline
\begin{lstlisting}

\end{lstlisting}\\
\hline
If Else & 
\begin{lstlisting}
mov eax, [ux]
cmp eax, 2 
ja else_body ; jump to else statements if condition is met

jmp after_if ; will only be hit when condition at "ja" was false

else_body: 
; will only be hit if condition at "ja" was true
after_if:
; will be hit by everything
\end{lstlisting}\\
\hline
do while in assembly & 
\textcolor{red}{The do while loop is the worst loop possible according to the professor. lol}\newline
\begin{lstlisting}
loop: 
  dec rcx
  jnz loop ; if rcx not z, go to loop
\end{lstlisting}\\
\hline
While in assembly & 
\begin{lstlisting}
mov rcx, 23 
jmp condition 

loop: 
  ; body -> do something 
condition: 
  dec rcx 
  jnz loop ; move to loop if rcx not 0
\end{lstlisting}\\
\hline
For in assembly & 
\begin{lstlisting}
mov rcx, 0

loop: 

  inc rcx
condition: 
  cmp rcx 10
  jle loop
\end{lstlisting}\\
\hline
Pointer-Addition in assembly & 
\pic{2022-10-25-04:40:00.png}\newline
\textcolor{teal}{We can add additional bytes to a pointer. \newline
in C: int *p = 0x20; -> p+1 == 0x24 -> p+2 == 0x28\newline
or simply use the ++p for the same as p+1}
\, \newline
\begin{lstlisting}
extern int *begin; // defined somewhere else 
extern int *end;   // defined somewhere else 
int sum = 0;
for (int *p = begin; p != end; ++p) {
sum += *p; // same as regular for loop just with pointer instead
 ;// then dereference the pointer here to get the value 
 ;// warning, if you go beyong what you should -> undefined behavior, likely segmentation fault!
}
\end{lstlisting}
\\
\hline
\end{tabular}
\end{table}
\pagebreak
\begin{table}[ht!]
\begin{tabular}{|m{0.2\linewidth}|m{0.755\linewidth}|}
\hline
Functions in assembly & 
\begin{lstlisting}
mov [opa_and512], op1a
mov [opb_and512], op1b
mov [res_and512], res1
mov [raddr_and512], after1
;the idea is that we store after 1 and go there when needed
and512:
    xor rcx, rcx

loop_and512:
    mov rax, [opa_and512 + 8 * rcx]
    mov rax, [opb_and512 + 8 * rcx]
    mov [res_adn512 + 8 * rcx], rax

    inc rcx
    cmp rcx, 8 
    jne loop_and512
    jmp [raddr_and512] ; move to after1

after1:
    ;do something
\end{lstlisting} 
\, \newline
\textcolor{orange}{We have an obvious problem with this, if we want to do a recursive function, we would need to define multiple global functions in order to get the proper behavior.}\newline
\begin{lstlisting}
S: 
    test rax, rax ;n == 0?
    js rsi

    mov rcx, rax
    dec rax
    mov rsi, after ; set rsi to after
    jump S 

after: 
    add rax, rcx ; as soon as we hit this code we have an endless loop!
    ; potential fix another register rso to after2:
    ; if ok jump to rso
    jump rsi
after2:
    ; do more
\end{lstlisting}
\, \newline
\textcolor{orange}{So what we would like to have is something like a stack:}\newline
\textcolor{orange}{Stack Push}\newline
\includegraphics[scale=0.4]{2022-11-08-03:34:38.png}
\includegraphics[scale=0.4]{2022-11-08-03:34:50.png}
\includegraphics[scale=0.4]{2022-11-08-03:34:43.png}\newline
\textcolor{orange}{Stack Pop}\newline
\includegraphics[scale=0.4]{2022-11-08-03:35:28.png}
\includegraphics[scale=0.4]{2022-11-08-03:35:38.png}
\includegraphics[scale=0.4]{2022-11-08-03:35:33.png}\newline
\textcolor{red}{IMPORTANT: The stack memory address decreases from top to bottom!!}\newline
\begin{lstlisting}
S: 
    test rax, rax ;n == 0?
    js rsi

    push rax
    dec rax
    push after
    jump S 

after: 
    pop rcx
    add rax, rcx
after2:
    pop rsi
    jmp rsi
\end{lstlisting}\\
\hline
call and ret & 
\textcolor{orange}{These are simply a combination of either push and jmp or pop and jmp:}\newline
\begin{itemize}
\item \textcolor{orange}{call = push rax and jmp a}
\item \textcolor{orange}{ret = pop rax and jmp rax}
\vspace{-2mm}
\end{itemize} 
\begin{lstlisting}
S: 
    test rax, rax
    jz final ; goto final if n == 0

    push rax
    dec rax
    call S ; goto S
    ; final will return here !!
    pop rcx 
    add rax, rcx
    ret ; return after we went to final 
final:
    ret ; return after where called
\end{lstlisting}\\
\hline
\end{tabular}
\end{table}
\pagebreak
\begin{table}[ht!]
\begin{tabular}{|m{0.2\linewidth}|m{0.755\linewidth}|}
\hline
Parameters on Stack & 
\textcolor{orange}{When we want to jump to a function, we first push the function to jump to in the stack, then its arguments, and then the return function.\newline
This means that the parameters will be on the stack until you return from the function.}\\
\hline
Frame Pointer & 
\textcolor{orange}{With each function call, the \textbf{frame pointer} will move back and forth,\newline
this requires a stable register for the frame pointer, this is the register \textbf{RBP (Base Pointer) on inte64}}\newline
\textcolor{teal}{Prolog}\newline
\begin{lstlisting}
push rpb ;push base pointer to stack
mov rbp, rsp ;rsp into rpb
\end{lstlisting} 
\, \newline
\textcolor{teal}{Epilog}\newline
\begin{lstlisting}
mov rsp, rpb ; move rpb into rsp 
pop rbp ; pop rbp from stack
\end{lstlisting}\\
\hline
Stack Allocation& 
\textcolor{orange}{You don't allocate or de-allocate every single variable one by one, instead you allocate or de-allocate it all at once:}\newline
\begin{lstlisting}
sub rsp, 0x20 ; allocates 0x20 bytes on stack
add rsp, 0x20 ; deallocates 0x20 bytes on stack
\end{lstlisting} 
\, \newline
\textcolor{orange}{You can then access the current result that is over the frame pointer like this:}\newline
\begin{lstlisting}
mov rcx, [rbp - 0x8] ; access memory for results
\end{lstlisting}\\
\hline
Parameters in Assembly & 
\textcolor{orange}{Since we do not have an integrated concept of functions, we need to handle the parameter passing ourselves.}\newline
\textcolor{purple}{Here we first push the parameter on to the stack, then we push the function pointer to the stack, this means that the function pointer is on the top.}\newline
\begin{lstlisting}
f: 
    push[x] // push the parameter to the stack
    call g  // push the function pointer to the stack
g: 
    push rbp 
    mov rbp, rsp 
     
    mov rcx, [rpb + 0x10]

    mov rsp, rbp 
    pop rbp 
    ret
\end{lstlisting}\\
\hline
Calling Conventions & 
\textcolor{orange}{The calling convention is the contract between the caller and the callee, it needs to define how the parameters will be passed, how the return values will be handled and how the stack will be built/reduced.}\newline
\textcolor{purple}{This can either be between a function and another function, or between a program and the operating system.}\\
\hline

\hline

\hline

\hline
\end{tabular}
\end{table}
\pagebreak
\begin{table}[ht!]
\begin{tabular}{|m{0.2\linewidth}|m{0.755\linewidth}|}
\hline

\hline

\hline

\hline

\hline

\hline

\hline

\hline

\hline

\hline

\hline
\end{tabular}
\end{table}
\pagebreak
\begin{table}[ht!]
\begin{tabular}{|m{0.2\linewidth}|m{0.755\linewidth}|}
\hline

\hline

\hline

\hline

\hline

\hline

\hline

\hline

\hline

\hline

\hline
\end{tabular}
\end{table}
\end{document}
